<script type="text/javascript">
  // define magic numbers
  const MP4FRAG = {
    hlsPlaylistSizeDef: 4,
    hlsPlaylistSizeMin: 2,
    hlsPlaylistSizeMax: 20,
    hlsPlaylistExtraDef: 0,
    hlsPlaylistExtraMin: 0,
    hlsPlaylistExtraMax: 10,
  };

  // register node
  RED.nodes.registerType('mp4frag', {
    align: 'left',
    category: 'cctv',
    color: '#DEBD5C',
    defaults: {
      name: {
        value: '',
      },
      hlsPlaylistSize: {
        value: MP4FRAG.hlsPlaylistSizeDef,
        required: true,
        validate: function (hlsPlaylistSize) {
          return hlsPlaylistSize >= MP4FRAG.hlsPlaylistSizeMin && hlsPlaylistSize <= MP4FRAG.hlsPlaylistSizeMax;
        },
      },
      hlsPlaylistExtra: {
        value: MP4FRAG.hlsPlaylistExtraDef,
        required: true,
        validate: function (hlsPlaylistExtra) {
          return hlsPlaylistExtra >= MP4FRAG.hlsPlaylistExtraMin && hlsPlaylistExtra <= MP4FRAG.hlsPlaylistExtraMax;
        },
      },
      basePath: {
        value: '',
        required: true,
        validate: RED.validators.regex(/^[a-z0-9_.]{1,50}$/i),
      },
      ffmpegRemaster: {
        value: true,
        required: true,
        validate: function (ffmpegRemaster) {
          return typeof ffmpegRemaster === 'boolean';
        },
      },
      ffmpegGlobal: {
        value: '-loglevel quiet',
        required: false,
        validate: function (ffmpegGlobal) {
          return typeof ffmpegGlobal === 'string';
        },
      },
      ffmpegInput: {
        value: '-f mp4',
        required: false,
        validate: function (ffmpegInput) {
          return typeof ffmpegInput === 'string';
        },
      },
      ffmpegOutput: {
        value: '-f mp4 -c copy -movflags +faststart+empty_moov',
        required: false,
        validate: function (ffmpegOutput) {
          return typeof ffmpegOutput === 'string';
        },
      },
    },
    icon: 'font-awesome/fa-file-video-o',
    inputLabels: 'buffer',
    inputs: 1,
    label: function () {
      if (this.name) {
        return this.name;
      }

      if (this.valid || (Array.isArray(this.validationErrors) && this.validationErrors.includes('basePath') === false)) {
        return `/mp4frag/${this.basePath}`;
      }

      return this.type;
    },
    outputLabels: ['playlist', 'buffer'],
    outputs: 2,
    oneditprepare: function () {
      // migration code start

      if (typeof this.ffmpegRemaster === 'undefined') {
        this.ffmpegRemaster = this._def.defaults.ffmpegRemaster.value;
      }

      if (typeof this.ffmpegGlobal === 'undefined') {
        $('#node-input-ffmpegGlobal').val(this._def.defaults.ffmpegGlobal.value);
      }

      if (typeof this.ffmpegInput === 'undefined') {
        $('#node-input-ffmpegInput').val(this._def.defaults.ffmpegInput.value);
      }

      if (typeof this.ffmpegOutput === 'undefined') {
        $('#node-input-ffmpegOutput').val(this._def.defaults.ffmpegOutput.value);
      }

      // migration code end

      $('#mp4fragFfmpegPath')
        .val(RED.settings.mp4fragFfmpegPath)
        .prop('readonly', true)
        .on('click', () => {
          RED.notify(this._('mp4frag.warning.ffmpeg_path'), { type: 'warning', id: 'mp4frag' });
          // type/color: error = red, warning = orange, success = green, '' = blue
        });

      $('#node-input-hlsPlaylistSize').typedInput({
        types: [
          {
            value: 'num',
            label: this._('mp4frag.label.hls_list_size'),
            icon: 'fa fa-list-ol',
            options: ['2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'],
          },
        ],
      });

      $('#node-input-hlsPlaylistExtra').typedInput({
        types: [
          {
            value: 'num',
            label: this._('mp4frag.label.hls_list_extra'),
            icon: 'fa fa-list-ol',
            options: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
          },
        ],
      });

      $('#node-input-basePath')
        .prop('placeholder', this.id)
        .on('input', function () {
          const newVal = this.value.replace(/[^a-z0-9_.]/gi, '');
          if (this.value !== newVal) {
            this.value = newVal;
          }
        });

      $('#node-input-ffmpegRemaster-container')
        .typedInput({ types: ['bool'] })
        .typedInput('value', this.ffmpegRemaster);

      $('<button type="button" class="red-ui-button red-ui-button-small"><i class="fa fa-book"></i> help</button>')
        .on('click', () => {
          RED.sidebar.help.show('mp4frag');
        })
        .appendTo($('div.red-ui-tray-footer'));
    },
    oneditsave: function () {
      const valToBool = (val, def) => {
        if (typeof val === 'boolean') {
          return val;
        }
        if (typeof val === 'string') {
          return val === 'true';
        }
        return def;
      };

      this.ffmpegRemaster = valToBool($('#node-input-ffmpegRemaster-container').typedInput('value'), this._def.defaults.ffmpegRemaster.value);

    },
  });
</script>

<script data-template-name="mp4frag" type="text/html">
  <div class="form-row">
    <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name" />
  </div>

  <fieldset>
    <legend>HLS Playlist Options</legend>

    <div class="form-row">
      <label for="node-input-hlsPlaylistSize"><i class="fa fa-list-ol"></i> Size</label>
      <input id="node-input-hlsPlaylistSize" />
    </div>

    <div class="form-row">
      <label for="node-input-hlsPlaylistExtra"><i class="fa fa-list-ol"></i> Extra</label>
      <input id="node-input-hlsPlaylistExtra" />
    </div>

    <div class="form-row">
      <label for="node-input-basePath"><i class="fa fa-globe"></i> URL</label>
      <code> /mp4frag/<input style="width:auto;text-align:center;" type="text" id="node-input-basePath" />/{resource} </code>
    </div>
  </fieldset>

  <fieldset>
    <legend>FFmpeg Options</legend>
    <div class="form-row">
      <label for="node-input-ffmpegRemaster-container"><i class="fa fa-play"></i> Remaster</label>
      <input type="text" id="node-input-ffmpegRemaster-container" />
    </div>

    <div class="form-row">
      <label for="mp4fragFfmpegPath"><i class="fa fa-picture-o"></i> Path</label>
      <input type="text" id="mp4fragFfmpegPath" />
    </div>

    <div class="form-row">
      <label for="node-input-ffmpegGlobal"><i class="fa fa-picture-o"></i> Global</label>
      <input type="text" id="node-input-ffmpegGlobal" />
    </div>

    <div class="form-row">
      <label for="node-input-ffmpegInput"><i class="fa fa-picture-o"></i> Input</label>
      <input type="text" id="node-input-ffmpegInput" />
    </div>

    <div class="form-row">
      <label for="node-input-ffmpegOutput"><i class="fa fa-picture-o"></i> Output</label>
      <input type="text" id="node-input-ffmpegOutput" />
    </div>
  </fieldset>
</script>

<script data-help-name="mp4frag" type="text/html">
  <h2>Parse a fragmented mp4 from a buffer and serve it as HLS.</h2>
  <p>After successfully parsing a fragmented mp4 from a buffer, it will send a msg containing the HLS Playlist in the payload.</p>
  <p><code class="form-tips">{ payload: '/mp4frag/example/hls.m3u8' }</code></p>
  <p>The HLS Playlist can be consumed by an app such as VLC, a video player library such as HLS.js, or natively in the Safari browser.</p>
  <h3>HLS Playlist Size</h3>
  <p>The number of segments to keep referenced inside the playlist.</p>
  <h3>HLS Playlist Extra</h3>
  <p>
    The number of extra segments to keep in memory beyond the playlist. This can be helpful if the video player falls behind and tries to
    access a segment that is no longer referenced in the playlist.
  </p>
  <h3>HLS Playlist URL</h3>
  <p>
    Choose a unique path for creating the http route to serve the HLS files. This affects the playlist, initialization fragment, and media
    segments.
  </p>
</script>
